package algorithms

import (
	"day_10/internal/abstractions"
	"fmt"
	"testing"
)

func TestRowReduction_ToHermiteNormalForm(t *testing.T) {
	tests := map[string]struct {
		matrixValues     [][]int64
		expectedMat      [][]int64
		expectedSolution []int64
	}{
		/* https://ksuweb.kennesaw.edu/~plaval/previous%20semesters/Fall2001/m3261_01/dm1.pdf*/
		"1.0-paper": {
			matrixValues: [][]int64{
				{1, 1, 0, 3, 4},
				{2, 1, -1, 1, 1},
				{3, -1, -1, 2, -3},
				{-1, 2, 3, -1, 4},
			},
			expectedMat: [][]int64{
				{1, 0, -1, -2, -3},
				{0, 1, 1, 5, 7},
				{0, 0, 3, 0, 0},
				{0, 0, 0, 13, 13},
			},
			expectedSolution: []int64{-1, 2, 0, 1},
		},
		"3.1-documented_use-case": {
			matrixValues: [][]int64{
				{0, 0, 0, 0, 1, 1, 3},
				{0, 1, 0, 0, 0, 1, 5},
				{0, 0, 1, 1, 1, 0, 4},
				{1, 1, 0, 1, 0, 0, 7},
			},
			expectedMat: [][]int64{
				{1, 0, 0, 1, 0, -1, 2},
				{0, 1, 0, 0, 0, 1, 5},
				{0, 0, 1, 1, 0, -1, 1},
				{0, 0, 0, 0, 1, 1, 3},
			},
			expectedSolution: []int64{1, 5, 0, 1, 3, 0},
		},
		"3.2-documented_use-case": {
			matrixValues: [][]int64{
				{1, 0, 1, 1, 0, 7},
				{0, 0, 0, 1, 1, 5},
				{1, 1, 0, 1, 1, 12},
				{1, 1, 0, 0, 1, 7},
				{1, 0, 1, 0, 1, 2},
			},
			expectedMat: [][]int64{
				{1, 0, 1, 0, 0, 2},
				{0, 1, -1, 0, 0, 5},
				{0, 0, 0, 0, 0, 0},
				{0, 0, 0, 1, 0, 5},
				{0, 0, 0, 0, 1, 0},
			},
			expectedSolution: []int64{2, 5, 0, 5, 0},
		},
		"3.3-documented_use-case": {
			matrixValues: [][]int64{
				{1, 1, 1, 0, 10},
				{1, 0, 1, 1, 11},
				{1, 0, 1, 1, 11},
				{1, 1, 0, 0, 5},
				{1, 1, 1, 0, 10},
				{0, 0, 1, 0, 5},
			},
			expectedMat: [][]int64{
				{1, 0, 0, 1, 6},
				{0, 1, 0, -1, -1},
				{0, 0, 1, 0, 5},
				{0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0},
			},
			expectedSolution: []int64{5, 0, 5, 1},
		},
		"machine.004-from_input": {
			matrixValues: [][]int64{
				{0, 1, 0, 12},
				{1, 1, 0, 29},
				{0, 0, 1, 128},
				{1, 1, 0, 29},
			},
			expectedMat: [][]int64{
				{1, 0, 0, 17},
				{0, 1, 0, 12},
				{0, 0, 1, 128},
				{0, 0, 0, 0},
			},
			expectedSolution: []int64{17, 12, 128},
		},
		"machine.005-from_input": {
			matrixValues: [][]int64{
				{1, 1, 1, 1, 37},
				{1, 0, 1, 0, 4},
				{0, 0, 1, 1, 21},
				{0, 1, 0, 1, 33},
			},
			expectedMat: [][]int64{
				{1, 0, 0, -1, -17},
				{0, 1, 0, 1, 33},
				{0, 0, 1, 1, 21},
				{0, 0, 0, 0, 0},
			},
			expectedSolution: []int64{0, 16, 4, 17},
		},
		"machine-006-from_input": {
			matrixValues: [][]int64{
				{1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 82},
				{1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 77},
				{1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 28},
				{1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 71},
				{0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 74},
				{1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 79},
				{1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 70},
				{1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 50},
				{1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 82},
				{0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 88},
			},
			expectedMat: [][]int64{
				{1, 0, 0, 0, 0, 0, 0, -1, 0, 2, -3, -2, -42},
				{0, 1, 0, 0, 0, 0, 0, 1, 0, -1, 1, 1, 36},
				{0, 0, 1, 0, 0, 0, 0, -1, 0, 1, 1, 1, 27},
				{0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 32},
				{0, 0, 0, 0, 1, 0, 0, 2, 0, -2, 0, 0, 12},
				{0, 0, 0, 0, 0, 1, 0, 1, 0, -1, -2, -2, -29},
				{0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 37},
				{0, 0, 0, 0, 0, 0, 0, 2, 0, -2, -3, -2, -66},
				{0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 21},
				{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 58},
			},
			expectedSolution: []int64{8, 20, 3, 14, 20, 15, 17, 0, 1, 4, 18, 2},
		},
		"machine.009-from_input": {
			matrixValues: [][]int64{
				{1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 72},
				{0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 59},
				{0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 15},
				{0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 37},
				{1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 47},
				{0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 16},
				{0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 48},
				{0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 32},
			},
			expectedMat: [][]int64{
				{1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 10},
				{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
				{0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 7},
				{0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 16},
				{0, 0, 0, 0, 1, 0, -1, 0, 0, 0, -2},
				{0, 0, 0, 0, 0, 1, 1, 0, 0, -1, 25},
				{0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 15},
				{0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 14},
			},
			expectedSolution: []int64{10, 0, 7, 16, 0, 23, 2, 15, 14, 0},
		},
		"machine.011-from_input": {
			matrixValues: [][]int64{
				{0, 0, 0, 1, 0, 1, 1, 1, 40},
				{0, 0, 1, 0, 1, 1, 0, 0, 203},
				{0, 1, 0, 0, 0, 1, 1, 0, 34},
				{1, 0, 0, 0, 0, 1, 0, 0, 33},
				{0, 0, 0, 0, 1, 1, 0, 1, 45},
				{0, 1, 0, 0, 0, 1, 0, 1, 51},
				{1, 0, 1, 0, 0, 1, 0, 0, 211},
				{0, 1, 1, 0, 0, 1, 0, 0, 209},
				{0, 0, 1, 1, 1, 0, 0, 1, 210},
				{0, 1, 0, 1, 1, 1, 0, 0, 43},
			},
			expectedMat: [][]int64{
				{1, 0, 0, 0, 0, 1, 0, 0, 33},
				{0, 1, 0, 0, 0, 1, 0, 0, 31},
				{0, 0, 1, 0, 0, 0, 0, 0, 178},
				{0, 0, 0, 1, 0, 1, 0, 0, 17},
				{0, 0, 0, 0, 1, 1, 0, 0, 25},
				{0, 0, 0, 0, 0, 2, 0, 0, 30},
				{0, 0, 0, 0, 0, 0, 1, 0, 3},
				{0, 0, 0, 0, 0, 0, 0, 1, 20},
				{0, 0, 0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0, 0, 0},
			},
			expectedSolution: []int64{18, 16, 178, 2, 10, 15, 3, 20},
		},
		"machine-033-from_input": {
			matrixValues: [][]int64{
				{1, 0, 1, 1, 0, 1, 0, 0, 33},
				{1, 1, 1, 0, 1, 0, 1, 0, 60},
				{1, 1, 0, 1, 1, 0, 0, 1, 46},
				{1, 1, 1, 1, 0, 0, 0, 0, 48},
				{0, 1, 0, 0, 1, 1, 1, 0, 30},
				{0, 1, 1, 1, 0, 0, 0, 0, 37},
				{1, 1, 1, 0, 1, 0, 0, 0, 58},
			},
			expectedMat: [][]int64{
				{1, 0, 0, 0, 0, -3, 0, 1, 15},
				{0, 1, 0, 0, 0, 2, 0, -1, 11},
				{0, 0, 1, 0, 0, 2, 0, -1, 15},
				{0, 0, 0, 1, 0, 2, 0, 0, 3},
				{0, 0, 0, 0, 1, 2, 0, 0, 13},
				{0, 0, 0, 0, 0, 3, 0, -1, -4},
				{0, 0, 0, 0, 0, 0, 1, 0, 2},
			},
			expectedSolution: []int64{11, 15, 19, 3, 13, 0, 2, 4},
		},
		"machine.124-from_input": {
			matrixValues: [][]int64{
				{1, 1, 1, 1, 0, 0, 0, 0, 32},
				{1, 1, 0, 1, 0, 1, 1, 1, 60},
				{1, 0, 0, 0, 1, 0, 1, 1, 29},
				{1, 1, 1, 1, 1, 0, 0, 1, 39},
				{0, 1, 0, 1, 0, 1, 1, 1, 57},
				{1, 1, 1, 1, 1, 0, 0, 0, 37},
				{1, 1, 0, 1, 1, 1, 1, 0, 63},
				{1, 1, 0, 0, 0, 0, 1, 1, 34},
			},
			expectedMat: [][]int64{
				{1, 0, 0, 0, 0, 0, 0, 0, 3},
				{0, 1, 0, 0, 0, 0, 0, 0, 10},
				{0, 0, 1, 0, 0, -1, 0, 0, -7},
				{0, 0, 0, 1, 0, 1, 0, 0, 26},
				{0, 0, 0, 0, 1, 0, 0, 0, 5},
				{0, 0, 0, 0, 0, 0, 1, 0, 19},
				{0, 0, 0, 0, 0, 0, 0, 1, 2},
				{0, 0, 0, 0, 0, 0, 0, 2, 4},
			},
			expectedSolution: []int64{3, 10, 0, 19, 5, 7, 19, 2},
		},
		"machine.133-from_input": {
			matrixValues: [][]int64{
				{1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 37},
				{1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 39},
				{1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 16},
				{1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 47},
				{1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 76},
				{1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 55},
				{1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 61},
				{0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 176},
				{0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 19},
			},
			expectedMat: [][]int64{
				{1, 0, 0, 0, 0, 0, 0, 0, -1, 0, -5},
				{0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 31},
				{0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 13},
				{0, 0, 0, 1, 0, -1, 0, 0, 1, 0, 166},
				{0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 21},
				{0, 0, 0, 0, 0, 0, 1, 0, -1, 0, -2},
				{0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 23},
				{0, 0, 0, 0, 0, 0, 0, 0, 2, -1, 16},
				{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8},
			},
			expectedSolution: []int64{7, 19, 1, 154, 21, 0, 10, 11, 12, 8},
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {

			// Create matrix and vector
			m := abstractions.FromSlice(tc.matrixValues)

			// Run the reduction
			rref := ToHermiteNormalForm(&abstractions.AugmentedMatrix{m}, true)

			actualRref := rref.Get()

			// Verify matrix results
			for row := 0; row < m.Rows(); row++ {
				for col := 0; col < m.Cols(); col++ {
					expected := tc.expectedMat[row][col]
					actual := actualRref.Get(row, col)
					if expected != actual {
						t.Errorf("Matrix[%d][%d]: expected %d, got %d", row, col, expected, actual)
					}
				}
			}

			actualSolution := rref.Solve(true)

			fmt.Println("Actual Solution")
			actualSolution.Print()

			fmt.Println("Expected solution")
			abstractions.PrintSlice(tc.expectedSolution)

			if actualSolution.Count() != uint64(len(tc.expectedSolution)) {
				t.Errorf("Solution length: expected %d, got %d", len(tc.expectedSolution), actualSolution.Count())
			} else {
				for i := 0; i < len(tc.expectedSolution); i++ {
					expected := tc.expectedSolution[i]
					actual := actualSolution.GetValue(abstractions.VariableNumber(i + 1))
					if expected != actual {
						t.Errorf("Solution[%d]: expected %d, got %d", i, expected, actual)
					}
				}
			}
		})
	}
}
